发布时间：2015-10-01
更新时间：2015-10-01 17:16:58
[github 本博客项目](https://github.com/SimplyY/Blog/)
# thinkinjava读书笔记（二）：类的基本语法

## 初始化


- 面向对象中的构造器的设计来确保对象的初始化
    > 在java中，“初始化”和“创建”捆绑在一起，两者不能分离，有助于减少忘记初始化而产生的错误，并使代码更易于阅读
- 不能以返回类型区分重载方法
- 默认构造器
    1. 系统会自动帮你创建，但是如果已经定义了一个构造器（无论是否有参数），编译器不会再自动创建。
    2. 子类的默认构造器会自动调用父类的默认构造器，**子类的非默认构造器不会自动调用父类的构造器（所以需要自己手动调用）**
	- 构造器实际上是静态方法
- 自动初始化
    - 非构造器或调用方法初始化为自动初始化有两种：
        1. **类的实例变量声明处的初始化**，在实例化时被调用
        2. 类的静态变量声明出的初始化
    - 无法阻止自动初始化的进行，因为它在构造器被调用前被调用
	- **变量声明的先后顺序决定**变量的声明处初始化的调用顺序
- 显式的静态数据的初始化
    > 无论创建多少个对象，静态数据都**只占用一份储存区域**。
    - 静态初始化动作只进行一次
    - 在类被第一次加载的时候初始化
        1. 第一次创建对象的时候或者
        2. 第一次访问静态成员数据或方法的时候
- 可变参数列表：

```
private void function(int required, String ... trailing){
...
}
```


## 清理

- 当你遇到明确要清理对象时（比如更新ui），不要重写或调用finalize（这是垃圾回收器自动做的，当需要系统清理对象时，而不是你决定调用的时刻），而是另写一方法并适时调用它来完成这项工作。
- 一定不要使用或者重写finalize方法
    - 和c＋＋不同，虽然finalize类似于析构函数，但是finalize是不可知被调用时刻的（由垃圾回收器调用），而析构函数是可知调用时刻的。
    - 因此重写finalize毫无意义，你根本不知道它什么时候被调用。
- 必须的清理
    - 但是还是存在必须做的清理工作，特别是对于占用图形界面的类，如果不清理，切换图形界面时，图形界面会混乱。
    - 请是使用恰当的函数类完成这些任务，在安卓里activity类的ondestory完成了这件事（但是我们使用的时候，大部分的清理工作是由我们继承的父类完成的。）

## 访问权限控制
> 面向对象设计中需要考虑的基本问题：“如何把变动的事物与不变的事物区分开来”

- 类库的设计
    - 使用类库的程序员不能更改类库（此时类库就是不变的事物）
    - 但是类库必须知道使用类库的程序员到底使用了哪些方法，难以更新类库（任何一个方法都可能被调用，这样以来，所有方法的签名都不能更改），这时访问权限控制就解救了编写类库的程序员。
    - 通过访问权限，类库的更新可以更自由的更改类库使用者不能访问的函数。
- 程序的编写
    - 访问权限使得程序的模块更易分离，比如模块a中的private对于模块b就是不变的看不见的封装起来的，而访问权限中可见的部分则是暴露出来的接口。
    - 尽可能将一切方法都定位private，除非外部文件需要此方法。这是高内聚的基石，从而使程序能达到低耦合的。
    - 在编写程序的时候，通常我们是身兼两职的，既是底层类编写程序员，也是类使用程序员，所以当我们编写底层类的时候尤其要注意访问权限，以此来达到解耦的效果
- 包访问权限
    - Java中的package可以类比c＋＋的namespace。不同的是，包的名称和目录结构是相对应的。
    - 与c＋＋不同的是，包访问权限（语法就是不加修饰词）。在同一个包里才可见。



易错
----

- static方法里是没有this的，因为**静态方法是属于整个类的，并不是某个对象**。static属性性质与其相似。
