发布时间：2015-10-01
更新时间：2015-10-01 17:16:58
[github 本博客项目](https://github.com/SimplyY/Blog/)  觉得文章不错快 star
# thinkinjava读书笔记（一）：对象 方法 操作符
## 对象导论

- 对万物**分类**的意义
	> 我们之所以将自然界**分解，组织成各种概念，并按其含义分类、起名字**，主要是因为我们是整个口语交流社会共同的协定的参与者，这个**协定**以语言的形式固定下来.....除非赞同这个协定，否则我们根本无法交谈。

- 解决问题的复杂性（一般和难度成正比）直接取决于抽象的类型和质量（**程度**）。
- （初学很容易弄混淆）在程序中你所可以使用的变量名实际上只是**对象的引用**（并不是对象）
- （初学很容易弄混淆）对象存放在堆（**没有任何引用指向的对象**，在某些时候会由垃圾回收器清理），变量在堆栈（离开作用域，就会被清理）

方法 操作符
----

- 方法名 + 参数列表 = 函数的签名（不含返回值）
- 如果传入参数的类型名是所需类型的子类，则会自动向上转型；如果传入是基本类型，窄化（数据量变小了，比如精度变低）是不准许的。
- 指数表示：e10和E10表示的是10的十次方。
- 当需要用来判断对象的所有属性是否相等时，**equal需要重写**(除了String可以直接用)，不然就和==(判断地址是否相等)效果一样（因为所有类都继承于Object，而其的equal方法就是用==来判断，而String重写了）
- arraylist(所有容器collection只能储存对象，int等不能储存)，get返回对象，indexof返回index


**极容易出错**的地方
----

- =，== 操作对象的时候都是**对引用**进行使用和比较
- 判断String类型的字符串是否相等 **用 equals（）**，==只是对引用进行比较！
- 切记一定不要将null当做参数传入函数，特别是准备在函数里面实例化参数的时候，这时由于函数外的null变量的并没有指向堆空间，所以函数内部的实例化无效（对外部不起作用）
- 也不要多次给引用实例化，特别是不要在函数里传参数进去实例化，这样实例化出来的对象的引用（变量）的作用域只是在函数内（参数的作用域，同样对外部不起作用）。
- foreach仅仅是在这样做
	> int(或某种数据类型) element = array[i]

	- 所以，对element赋值 ，不会改变array[i]，然而对**对象反之**，因为对象的=是将引用给element，这样一来element的改变必然会改变array[i]。
- 数组都是对象，比如
	> int a[] = {1,2};
	> b = a;

	此时当且仅有一个数组在堆空间里，也就是说，无论是对a，还是b其中的一个做了改变，他们会同时改变
